{"ast":null,"code":"import { errorPrefix } from \"tsparticles-engine\";\nimport { replaceImageColor } from \"./Utils\";\nexport class ImageDrawer {\n  constructor(engine) {\n    this.loadImageShape = async imageShape => {\n      if (!this._engine.loadImage) {\n        throw new Error(`${errorPrefix} image shape not initialized`);\n      }\n      await this._engine.loadImage({\n        name: imageShape.name,\n        replaceColor: imageShape.replaceColor ?? imageShape.replace_color ?? false,\n        src: imageShape.src\n      });\n    };\n    this._engine = engine;\n  }\n  addImage(image) {\n    if (!this._engine.images) {\n      this._engine.images = [];\n    }\n    this._engine.images.push(image);\n  }\n  draw(context, particle, radius, opacity) {\n    const image = particle.image,\n      element = image?.element;\n    if (!element) {\n      return;\n    }\n    const ratio = image?.ratio ?? 1,\n      pos = {\n        x: -radius,\n        y: -radius\n      };\n    context.globalAlpha = opacity;\n    context.drawImage(element, pos.x, pos.y, radius * 2, radius * 2 / ratio);\n    context.globalAlpha = 1;\n  }\n  getSidesCount() {\n    return 12;\n  }\n  async init(container) {\n    const options = container.actualOptions;\n    if (!options.preload || !this._engine.loadImage) {\n      return;\n    }\n    for (const imageData of options.preload) {\n      this._engine.loadImage(imageData);\n    }\n  }\n  loadShape(particle) {\n    if (particle.shape !== \"image\" && particle.shape !== \"images\") {\n      return;\n    }\n    if (!this._engine.images) {\n      this._engine.images = [];\n    }\n    const imageData = particle.shapeData,\n      image = this._engine.images.find(t => t.name === imageData.name || t.source === imageData.src);\n    if (!image) {\n      this.loadImageShape(imageData).then(() => {\n        this.loadShape(particle);\n      });\n    }\n  }\n  particleInit(container, particle) {\n    if (particle.shape !== \"image\" && particle.shape !== \"images\") {\n      return;\n    }\n    if (!this._engine.images) {\n      this._engine.images = [];\n    }\n    const images = this._engine.images,\n      imageData = particle.shapeData,\n      color = particle.getFillColor(),\n      image = images.find(t => t.name === imageData.name || t.source === imageData.src);\n    if (!image) {\n      return;\n    }\n    const replaceColor = imageData.replaceColor ?? imageData.replace_color ?? image.replaceColor;\n    if (image.loading) {\n      setTimeout(() => {\n        this.particleInit(container, particle);\n      });\n      return;\n    }\n    (async () => {\n      let imageRes;\n      if (image.svgData && color) {\n        imageRes = await replaceImageColor(image, imageData, color, particle);\n      } else {\n        imageRes = {\n          color,\n          data: image,\n          element: image.element,\n          loaded: true,\n          ratio: imageData.width && imageData.height ? imageData.width / imageData.height : image.ratio ?? 1,\n          replaceColor: replaceColor,\n          source: imageData.src\n        };\n      }\n      if (!imageRes.ratio) {\n        imageRes.ratio = 1;\n      }\n      const fill = imageData.fill ?? particle.fill,\n        close = imageData.close ?? particle.close,\n        imageShape = {\n          image: imageRes,\n          fill,\n          close\n        };\n      particle.image = imageShape.image;\n      particle.fill = imageShape.fill;\n      particle.close = imageShape.close;\n    })();\n  }\n}","map":{"version":3,"names":["errorPrefix","replaceImageColor","ImageDrawer","constructor","engine","loadImageShape","imageShape","_engine","loadImage","Error","name","replaceColor","replace_color","src","addImage","image","images","push","draw","context","particle","radius","opacity","element","ratio","pos","x","y","globalAlpha","drawImage","getSidesCount","init","container","options","actualOptions","preload","imageData","loadShape","shape","shapeData","find","t","source","then","particleInit","color","getFillColor","loading","setTimeout","imageRes","svgData","data","loaded","width","height","fill","close"],"sources":["/Users/michaelgedion/Documents/Javascript course/facerecognition/node_modules/tsparticles-shape-image/esm/ImageDrawer.js"],"sourcesContent":["import { errorPrefix } from \"tsparticles-engine\";\nimport { replaceImageColor } from \"./Utils\";\nexport class ImageDrawer {\n    constructor(engine) {\n        this.loadImageShape = async (imageShape) => {\n            if (!this._engine.loadImage) {\n                throw new Error(`${errorPrefix} image shape not initialized`);\n            }\n            await this._engine.loadImage({\n                name: imageShape.name,\n                replaceColor: imageShape.replaceColor ?? imageShape.replace_color ?? false,\n                src: imageShape.src,\n            });\n        };\n        this._engine = engine;\n    }\n    addImage(image) {\n        if (!this._engine.images) {\n            this._engine.images = [];\n        }\n        this._engine.images.push(image);\n    }\n    draw(context, particle, radius, opacity) {\n        const image = particle.image, element = image?.element;\n        if (!element) {\n            return;\n        }\n        const ratio = image?.ratio ?? 1, pos = {\n            x: -radius,\n            y: -radius,\n        };\n        context.globalAlpha = opacity;\n        context.drawImage(element, pos.x, pos.y, radius * 2, (radius * 2) / ratio);\n        context.globalAlpha = 1;\n    }\n    getSidesCount() {\n        return 12;\n    }\n    async init(container) {\n        const options = container.actualOptions;\n        if (!options.preload || !this._engine.loadImage) {\n            return;\n        }\n        for (const imageData of options.preload) {\n            this._engine.loadImage(imageData);\n        }\n    }\n    loadShape(particle) {\n        if (particle.shape !== \"image\" && particle.shape !== \"images\") {\n            return;\n        }\n        if (!this._engine.images) {\n            this._engine.images = [];\n        }\n        const imageData = particle.shapeData, image = this._engine.images.find((t) => t.name === imageData.name || t.source === imageData.src);\n        if (!image) {\n            this.loadImageShape(imageData).then(() => {\n                this.loadShape(particle);\n            });\n        }\n    }\n    particleInit(container, particle) {\n        if (particle.shape !== \"image\" && particle.shape !== \"images\") {\n            return;\n        }\n        if (!this._engine.images) {\n            this._engine.images = [];\n        }\n        const images = this._engine.images, imageData = particle.shapeData, color = particle.getFillColor(), image = images.find((t) => t.name === imageData.name || t.source === imageData.src);\n        if (!image) {\n            return;\n        }\n        const replaceColor = imageData.replaceColor ?? imageData.replace_color ?? image.replaceColor;\n        if (image.loading) {\n            setTimeout(() => {\n                this.particleInit(container, particle);\n            });\n            return;\n        }\n        (async () => {\n            let imageRes;\n            if (image.svgData && color) {\n                imageRes = await replaceImageColor(image, imageData, color, particle);\n            }\n            else {\n                imageRes = {\n                    color,\n                    data: image,\n                    element: image.element,\n                    loaded: true,\n                    ratio: imageData.width && imageData.height ? imageData.width / imageData.height : image.ratio ?? 1,\n                    replaceColor: replaceColor,\n                    source: imageData.src,\n                };\n            }\n            if (!imageRes.ratio) {\n                imageRes.ratio = 1;\n            }\n            const fill = imageData.fill ?? particle.fill, close = imageData.close ?? particle.close, imageShape = {\n                image: imageRes,\n                fill,\n                close,\n            };\n            particle.image = imageShape.image;\n            particle.fill = imageShape.fill;\n            particle.close = imageShape.close;\n        })();\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}